
```{r}

# Load libraries and set seed
install.packages("pacman")
pacman::p_load(R2jags, parallel, ggpubr, extraDistr, truncnorm, ggplot2, gridExtra)
set.seed(123)

```

```{r}
setwd('/work/SofieNørboMosegaard#5741/DecisionMaking_exam/src')

```


```{r}
# Define function for calculating the maximum of the posterior density 
MPD <- function(x) {density(x)$x[which(density(x)$y==max(density(x)$y))]}

```

12.35
- forventet færdig 13.15

```{r}

# Set parameters for the simulation
nsub <- 24
group_size <- 6
ngroups <- nsub / group_size
ntypes <- 2

# mu
true_mu_alpha <- array(NA, c(nsub, ngroups, ntypes))
true_mu_rho <- array(NA, c(nsub, ngroups, ntypes))

infer_mu_alpha<- array(NA, c(nsub, ngroups, ntypes))
infer_mu_rho <- array(NA, c(nsub, ngroups, ntypes))

# sigma
true_sigma_alpha <- array(NA, c(nsub, ngroups, ntypes))
true_sigma_rho <- array(NA, c(nsub, ngroups, ntypes))

infer_sigma_alpha<- array(NA, c(nsub, ngroups, ntypes))
infer_sigma_rho <- array(NA, c(nsub, ngroups, ntypes))


for (t in 1:ntypes) {
  for (g in 1:ngroups) {
    for (s in 1:nsub) {
      
      # mean for alpha and rho
      mu_alpha <- runif(1, 0, 10) # one can contribute w 0-10 tokens
      mu_rho <- runif(1, 0.1, 0.9) # between 0 and 1 without the extreme values
      
      # standard deviation for alpha and rho
      sigma_alpha <- runif(1, 0.01, 0.1)
      sigma_rho <- runif(1, 0.01, 0.1)
      
      # Simulate data
      source("CC.R")
      CC_sims <- CC_simulation(nsub, ngroups, ntypes, mu_alpha, mu_rho, sigma_alpha, sigma_rho)
      
      # Store the c and Gb from the simulation
      c <- CC_sims$c
      Gb <- CC_sims$Gb
      
      # set up jags and run model
      data <- list("c", "Gb", "nsub", "ngroups", "ntypes") 
      params <- c("mu_alpha","mu_rho", "sigma_alpha", "sigma_rho")
      samples <- jags.parallel(data,
                               inits = NULL,
                               params,
                               model.file = "CC.txt",
                               n.chains = 3, 
                               n.iter = 5000,
                               n.burnin = 1500,
                               n.thin = 1,
                               n.cluster = 3,
                               jags.seed = 123)
      
      # store true parameters
      true_mu_alpha[s, g, t] <- mu_alpha
      true_mu_rho[s, g, t] <- mu_rho
      
      true_sigma_alpha[s, g, t] <- sigma_alpha
      true_sigma_rho[s, g, t] <- sigma_rho
      
      # extract recovered parameters (maximum a posteriori)
      Y <- samples$BUGSoutput$sims.list
      
      infer_mu_alpha[s, g, t] <- MPD(Y$mu_alpha)
      infer_mu_rho[s, g, t] <- MPD(Y$mu_rho)
      
      infer_sigma_alpha[s, g, t] <- MPD(Y$sigma_alpha)
      infer_sigma_rho[s, g, t] <- MPD(Y$sigma_rho)
      
    }
  }
}

# Plotting!
source("plot_functions.R")

# had some "length" issues with plotting --> works when flattening to 1D vectors:
true_mu_alpha_vec <- as.vector(true_mu_alpha)
infer_mu_alpha_vec <- as.vector(infer_mu_alpha)
true_mu_rho_vec <- as.vector(true_mu_rho)
infer_mu_rho_vec <- as.vector(infer_mu_rho)
true_sigma_alpha_vec <- as.vector(true_sigma_alpha)
infer_sigma_alpha_vec <- as.vector(infer_sigma_alpha)
true_sigma_rho_vec <- as.vector(true_sigma_rho)
infer_sigma_rho_vec <- as.vector(infer_sigma_rho)


df <- data.frame(parameter = rep(c("mu_alpha", "mu_rho", "sigma_alpha", "sigma_rho"), 
                                 each = length(true_mu_alpha_vec)),
                 true = c(true_mu_alpha_vec, true_mu_rho_vec, 
                          true_sigma_alpha_vec, true_sigma_rho_vec),
                 infer = c(infer_mu_alpha_vec, infer_mu_rho_vec, 
                           infer_sigma_alpha_vec, infer_sigma_rho_vec))

plot_mu <- recovery_plots(df, parameter_filter = c("mu_alpha", "mu_rho"))
plot_sigma <- recovery_plots(df, parameter_filter = c("sigma_alpha", "sigma_rho"))

ggsave("../plots/recov_plot_mu.png", plot_mu, width = 8, height = 6, dpi = 300)
ggsave("../plots/recov_plot_sigma.png", plot_sigma, width = 8, height = 6, dpi = 300)

combined_plot <- grid.arrange(plot_mu, plot_sigma, nrow = 2)
ggsave("../plots/recov_combined_plot.png", combined_plot, width = 12, height = 12, dpi = 300)


# Additional plotting
pl1 <- recov_plot(true_mu_alpha_vec, infer_mu_alpha_vec, c("true mu_alpha", "inferred mu_alpha"), 'smoothed linear fit')
ggsave("../plots/recovery_mu_alpha.png", plot = pl1, width = 6, height = 6, dpi = 300)

pl2 <- recov_plot(true_mu_rho_vec, infer_mu_rho_vec, c("true mu_rho", "inferred mu_rho"), 'smoothed linear fit')
ggsave("../plots/recovery_mu_rho.png", plot = pl2, width = 6, height = 6, dpi = 300)

combined_plot1 <- ggarrange(pl1, pl2)
ggsave("../plots/recovery_mu_alpha_rho.png", plot = combined_plot1, width = 12, height = 6, dpi = 300)

pl3 <- recov_plot(true_sigma_alpha_vec, infer_sigma_alpha_vec, c("true sigma_alpha", "inferred sigma_alpha"), 'smoothed linear fit')
ggsave("../plots/recovery_sigma_alpha.png", plot = pl3, width = 6, height = 6, dpi = 300)

pl4 <- recov_plot(true_sigma_rho_vec, infer_sigma_rho_vec, c("true sigma_rho", "inferred sigma_rho"), 'smoothed linear fit')
ggsave("../plots/recovery_sigma_rho.png", plot = pl4, width = 6, height = 6, dpi = 300)

combined_plot2 <- ggarrange(pl3, pl4)
ggsave("../plots/recovery_sigma_alpha_rho.png", plot = combined_plot2, width = 12, height = 6, dpi = 300)


# Save data
save(samples,
     nsub,
     ngroups,
     ntypes,
     true_mu_alpha,
     true_mu_rho,
     infer_mu_alpha,
     infer_mu_rho,
     true_sigma_alpha,
     true_sigma_rho,
     infer_sigma_alpha,
     infer_sigma_rho,
     file = "../jags_output/hier_CC_recovery_samples.RData")


```


```{r}

# Plotting!
source("plot_functions.R")

# had some "length" issues with plotting --> works when flattening to 1D vectors:
true_mu_alpha_vec <- as.vector(true_mu_alpha)
infer_mu_alpha_vec <- as.vector(infer_mu_alpha)
true_mu_rho_vec <- as.vector(true_mu_rho)
infer_mu_rho_vec <- as.vector(infer_mu_rho)
true_sigma_alpha_vec <- as.vector(true_sigma_alpha)
infer_sigma_alpha_vec <- as.vector(infer_sigma_alpha)
true_sigma_rho_vec <- as.vector(true_sigma_rho)
infer_sigma_rho_vec <- as.vector(infer_sigma_rho)


df <- data.frame(parameter = rep(c("mu_alpha", "mu_rho", "sigma_alpha", "sigma_rho"), 
                                 each = length(true_mu_alpha_vec)),
                 true = c(true_mu_alpha_vec, true_mu_rho_vec, 
                          true_sigma_alpha_vec, true_sigma_rho_vec),
                 infer = c(infer_mu_alpha_vec, infer_mu_rho_vec, 
                           infer_sigma_alpha_vec, infer_sigma_rho_vec))

plot_mu <- recovery_plots(df, parameter_filter = c("mu_alpha", "mu_rho"))
plot_sigma <- recovery_plots(df, parameter_filter = c("sigma_alpha", "sigma_rho"))

ggsave("../plots/recov_plot_mu.png", plot_mu, width = 8, height = 6, dpi = 300)
ggsave("../plots/recov_plot_sigma.png", plot_sigma, width = 8, height = 6, dpi = 300)

combined_plot <- grid.arrange(plot_mu, plot_sigma, nrow = 2)
ggsave("../plots/recov_combined_plot.png", combined_plot, width = 12, height = 12, dpi = 300)


# Additional plotting
pl1 <- recov_plot(true_mu_alpha_vec, infer_mu_alpha_vec, c("true mu_alpha", "inferred mu_alpha"), 'smoothed linear fit')
ggsave("../plots/recovery_mu_alpha.png", plot = pl1, width = 6, height = 6, dpi = 300)

pl2 <- recov_plot(true_mu_rho_vec, infer_mu_rho_vec, c("true mu_rho", "inferred mu_rho"), 'smoothed linear fit')
ggsave("../plots/recovery_mu_rho.png", plot = pl2, width = 6, height = 6, dpi = 300)

combined_plot1 <- ggarrange(pl1, pl2)
ggsave("../plots/recovery_mu_alpha_rho.png", plot = combined_plot1, width = 12, height = 6, dpi = 300)

pl3 <- recov_plot(true_sigma_alpha_vec, infer_sigma_alpha_vec, c("true sigma_alpha", "inferred sigma_alpha"), 'smoothed linear fit')
ggsave("../plots/recovery_sigma_alpha.png", plot = pl3, width = 6, height = 6, dpi = 300)

pl4 <- recov_plot(true_sigma_rho_vec, infer_sigma_rho_vec, c("true sigma_rho", "inferred sigma_rho"), 'smoothed linear fit')
ggsave("../plots/recovery_sigma_rho.png", plot = pl4, width = 6, height = 6, dpi = 300)

combined_plot2 <- ggarrange(pl3, pl4)
ggsave("../plots/recovery_sigma_alpha_rho.png", plot = combined_plot2, width = 12, height = 6, dpi = 300)


# Save data
save(samples,
     nsub,
     ngroups,
     ntypes,
     true_mu_alpha,
     true_mu_rho,
     infer_mu_alpha,
     infer_mu_rho,
     true_sigma_alpha,
     true_sigma_rho,
     infer_sigma_alpha,
     infer_sigma_rho,
     file = "../jags_output/hier_CC_recovery_samples.RData")

```

```{r}
pacman::p_load(haven, dplyr)
```


```{r}

setwd('/work/SofieNørboMosegaard#5741/DecisionMaking_exam/src')


# Define function for calculating the maximum of the posterior density 
MPD <- function(x) {density(x)$x[which(density(x)$y==max(density(x)$y))]}

# Load data
Leb_PGG_3_Clean_FINAL <- read_dta('../data/Leb_PGG_3_Clean_FINAL.dta')

# Prepare data
df <- Leb_PGG_3_Clean_FINAL %>%
  
  # filter to only include Shia Female
  filter(sect == 'Sh', female == 1) %>%
  filter(final_assign == 1 | final_assign == 3) %>% 
  
  # Assign class_type (rich/poor)
  mutate(class_type = case_when(
    rich == 1 & poor == 0 ~ "rich",
    poor == 1 & rich == 0 ~ "poor",)) %>% 
  
  # Assign type (mix, same)
  mutate(type = case_when(
    T_mixed_class == 1 ~ "mix",
    T_mixed_class == 0 ~ "same",)) %>% 
  
  # Assign group_class (same_class_rich, same_class_poor, mixed_class)
  group_by(gid) %>%
  mutate(group_class = case_when(
    all(class_type == "rich") ~ "same_class_rich",
    all(class_type == "poor") ~ "same_class_poor",
    any(class_type == "rich") & any(class_type == "poor") ~ "mixed_class",)) %>% 
  
  # Scale contribution by 1000, so the "token range" is 0:10
  mutate(pgg_rd1 = pgg_rd1 / 1000) %>% 
  
  # Remove NAs
  filter(!is.na(pgg_rd1)) %>% 
  
  # Select columns of interest
  select(gid, pid, type, class_type, group_class, female, sect, pre_q2_age, pgg_rd1, pgg_rd1_totalpot)


# Split data into mix and same types
type_mix <- df %>% filter(type == 'mix')
type_same <- df %>% filter(type == 'same')

# Define nsub, ngroups, ntypes
subID_mix <- unique(type_mix$pid)
nsub_mix <- length(subID_mix) # 24
groupID_mix <- unique(type_mix$gid)
ngroups_mix <- length(groupID_mix) # 4 (with 6 subs in each)
ntypeID_mix <- unique(type_mix$type)
ntypes_mix <- length(ntypeID_mix) # 1

subID_same <- unique(type_same$pid)
nsub_same <- length(subID_same) # 24
groupID_same <- unique(type_same$gid)
ngroups_same <- length(groupID_same) # 4
ntypeID_same <- unique(type_same$type)
ntypes_same <- length(ntypeID_same) # 1

# Initialize empty arrays for c
c_mix <- array(NA, c(nsub_mix, ngroups_mix, 1))
c_same <- array(NA, c(nsub_same, ngroups_same, 1))

# Define function that loops through each group to assign subjects' pgg_rd1 (i.e. c) value
setup_arrays_c <- function(data, subID, groupID, c_array, nsub, ngroups) {
  for (g in 1:ngroups) {
    for (s in 1:nsub) {
      subject_data <- data %>%
        filter(gid == groupID[g] & pid == subID[s])
      if (nrow(subject_data) == 1) {
        c_array[s, g, 1] <- subject_data$pgg_rd1
      } else if (nrow(subject_data) > 1) {
        c_array[s, g, 1] <- subject_data$pgg_rd1[1] # Assign first value, caused error without 
      }
    }
  }
  
  return(c_array)
}

c_mix <- setup_arrays_c(type_mix, subID_mix, groupID_mix, c_mix, nsub_mix, ngroups_mix)
c_same <- setup_arrays_c(type_same, subID_same, groupID_same, c_same, nsub_same, ngroups_same)

# prepare for jags 
data_mix <- list(c = c_mix, nsub = nsub_mix, ngroups = ngroups_mix, ntypes = ntypes_mix)
data_same <- list(c = c_same, nsub = nsub_same, ngroups = ngroups_same, ntypes = ntypes_same)

params <- c("mu_alpha", "mu_rho")


# Run jags
samples_mix <- jags.parallel(data_mix, inits = NULL, params,
                             model.file = "CC.txt",
                             n.chains = 3, n.iter = 20000, n.burnin = 5000,
                             n.thin = 1, n.cluster = 4, jags.seed = 123)
save(samples_mix, file = "../jags_output/mix_estimation_samples.RData")


samples_same <- jags.parallel(data_same, inits = NULL, params,
                             model.file = "CC.txt",
                             n.chains = 3, n.iter = 20000, n.burnin = 5000,
                             n.thin = 1, n.cluster = 4, jags.seed = 123)
save(samples_same, file = "../jags_output/same_estimation_samples.RData")


# Plotting!
# Posterior density plots for alpha and rho, both types
source("plot_functions.R")

png("../plots/mix_posterior.png", width = 8, height = 6, units = "in", res = 300)
posterior_plots(samples_mix, "mixed-class type")
dev.off() 

png("../plots/same_posterior.png", width = 8, height = 6, units = "in", res = 300)
posterior_plots(samples_same, "same-class type")
dev.off() 

# Construct the data frame
length_mix <- length(samples_mix$BUGSoutput$sims.list$mu_alpha)
length_same <- length(samples_same$BUGSoutput$sims.list$mu_alpha)
total_length <- length_mix + length_same

df <- data.frame(parameter = rep(c("alpha", "rho"),
                                 each = total_length),
                 type = rep(rep(c("mix", "same"),
                                each = total_length/2), 2),
                 samples = c(samples_mix$BUGSoutput$sims.list$mu_alpha, 
                             samples_same$BUGSoutput$sims.list$mu_alpha,
                             samples_mix$BUGSoutput$sims.list$mu_rho,
                             samples_same$BUGSoutput$sims.list$mu_rho))


pl3 <- combined_posterior_plots(df)
ggsave("../plots/combined_posterior_plots.png", plot = pl3, width = 6, height = 6, dpi = 300)

# trace plots
png("../plots/traceplot_samples_mix.png", width = 800, height = 600)
traceplot(samples_mix, mfrow = c(3,1))
dev.off()

png("../plots/traceplot_samples_same.png", width = 800, height = 600)
traceplot(samples_same, mfrow = c(3, 1))
dev.off()

```

```{r}
samples_mix

```

```{r}
# Generate the summary of the samples
summary_mix <- summary(samples_mix)

# Print the summary to the console
print(summary_mix)

# Save the summary to a text file
write(summary_mix, file = "../jags_output/mix_estimation_summary.txt")

```

```{r}
# Save the sample table as .txt by captureing the printed output
output <- capture.output(print(samples_mix))
writeLines(output, con = "../jags_output/mix_estimation_summary.txt")
```


```{r}
output <- capture.output(print(samples_same))
writeLines(output, con = "../jags_output/same_estimation_summary.txt")
```


```{r}
summary_mix <- print(samples_mix)

```



```{r}
samples_same
             
```




```{r}
# Define function for calculating the maximum of the posterior density 
MPD <- function(x) {density(x)$x[which(density(x)$y==max(density(x)$y))]}

# Load data
Leb_PGG_3_Clean_FINAL <- read_dta('../data/Leb_PGG_3_Clean_FINAL.dta')

# Prepare data
df <- Leb_PGG_3_Clean_FINAL %>%
  
  # filter to only include Shia Female
  filter(sect == 'Sh', female == 1) %>%
  filter(final_assign == 1 | final_assign == 3) %>% 
  
  # Assign class_type (rich/poor)
  mutate(class_type = case_when(
    rich == 1 & poor == 0 ~ "rich",
    poor == 1 & rich == 0 ~ "poor",)) %>% 
  
  # Assign type (mix, same)
  mutate(type = case_when(
    T_mixed_class == 1 ~ "mix",
    T_mixed_class == 0 ~ "same",)) %>% 
  
  # Assign group_class (same_class_rich, same_class_poor, mixed_class)
  group_by(gid) %>%
  mutate(group_class = case_when(
    all(class_type == "rich") ~ "same_class_rich",
    all(class_type == "poor") ~ "same_class_poor",
    any(class_type == "rich") & any(class_type == "poor") ~ "mixed_class",)) %>% 
  
  # Scale contribution by 1000, so the "token range" is 0:10
  mutate(pgg_rd1 = pgg_rd1 / 1000) %>% 
  
  # Remove NAs
  filter(!is.na(pgg_rd1)) %>% 
  
  # Select columns of interest
  select(gid, pid, type, class_type, group_class, female, sect, pre_q2_age, pgg_rd1, pgg_rd1_totalpot)


# Split data into mix and same types
type_mix <- df %>% filter(type == 'mix')
type_same <- df %>% filter(type == 'same')

# Define nsub, ngroups, ntypes
subID_mix <- unique(type_mix$pid)
nsub_mix <- length(subID_mix) # 24
groupID_mix <- unique(type_mix$gid)
ngroups_mix <- length(groupID_mix) # 4 (with 6 subs in each)
ntypeID_mix <- unique(type_mix$type)
ntypes_mix <- length(ntypeID_mix) # 1

subID_same <- unique(type_same$pid)
nsub_same <- length(subID_same) # 24
groupID_same <- unique(type_same$gid)
ngroups_same <- length(groupID_same) # 4
ntypeID_same <- unique(type_same$type)
ntypes_same <- length(ntypeID_same) # 1

# Initialize empty arrays for c
c_mix <- array(NA, c(nsub_mix, ngroups_mix, 1))
c_same <- array(NA, c(nsub_same, ngroups_same, 1))

# Define function that loops through each group to assign subjects' pgg_rd1 (i.e. c) value
setup_arrays_c <- function(data, subID, groupID, c_array, nsub, ngroups) {
  for (g in 1:ngroups) {
    for (s in 1:nsub) {
      subject_data <- data %>%
        filter(gid == groupID[g] & pid == subID[s])
      if (nrow(subject_data) == 1) {
        c_array[s, g, 1] <- subject_data$pgg_rd1
      } else if (nrow(subject_data) > 1) {
        c_array[s, g, 1] <- subject_data$pgg_rd1[1] # Assign first value, caused error without 
      }
    }
  }
  
  return(c_array)
}

c_mix <- setup_arrays_c(type_mix, subID_mix, groupID_mix, c_mix, nsub_mix, ngroups_mix)
c_same <- setup_arrays_c(type_same, subID_same, groupID_same, c_same, nsub_same, ngroups_same)

# prepare for jags 
data_mix <- list(c = c_mix, nsub = nsub_mix, ngroups = ngroups_mix, ntypes = ntypes_mix)
data_same <- list(c = c_same, nsub = nsub_same, ngroups = ngroups_same, ntypes = ntypes_same)

params <- c("mu_alpha", "mu_rho")

# Run jags
samples_mix <- jags.parallel(data_mix, inits = NULL, params,
                             model.file = "CC.txt",
                             n.chains = 3, n.iter = 20000, n.burnin = 5000,
                             n.thin = 1, n.cluster = 4, jags.seed = 123)
save(samples_mix, file = "../jags_output/mix_estimation_samples.RData")


samples_same <- jags.parallel(data_same, inits = NULL, params,
                             model.file = "CC.txt",
                             n.chains = 3, n.iter = 20000, n.burnin = 5000,
                             n.thin = 1, n.cluster = 4, jags.seed = 123)
save(samples_same, file = "../jags_output/same_estimation_samples.RData")


# Plotting!
# Posterior density plots for alpha and rho, both types
source("plot_functions.R")

png("../plots/mix_posterior.png", width = 8, height = 6, units = "in", res = 300)
posterior_plots(samples_mix, "mixed-class type")
dev.off() 

png("../plots/same_posterior.png", width = 8, height = 6, units = "in", res = 300)
posterior_plots(samples_same, "same-class type")
dev.off() 

# Construct the data frame
length_mix <- length(samples_mix$BUGSoutput$sims.list$mu_alpha)
length_same <- length(samples_same$BUGSoutput$sims.list$mu_alpha)
total_length <- length_mix + length_same

df <- data.frame(parameter = rep(c("alpha", "rho"),
                                 each = total_length),
                 type = rep(rep(c("mix", "same"),
                                each = total_length/2), 2),
                 samples = c(samples_mix$BUGSoutput$sims.list$mu_alpha, 
                             samples_same$BUGSoutput$sims.list$mu_alpha,
                             samples_mix$BUGSoutput$sims.list$mu_rho,
                             samples_same$BUGSoutput$sims.list$mu_rho))


pl3 <- combined_posterior_plots(df)
ggsave("../plots/combined_posterior_plots.png", plot = pl3, width = 6, height = 6, dpi = 300)

# trace plots
png("../plots/traceplot_samples_mix.png", width = 800, height = 600)
traceplot(samples_mix, mfrow = c(3,1))
dev.off()

png("../plots/traceplot_samples_same.png", width = 800, height = 600)
traceplot(samples_same, mfrow = c(3, 1))
dev.off()

```

# Comparison

```{r}

# Define function for calculating the maximum of the posterior density 
MPD <- function(x) {density(x)$x[which(density(x)$y==max(density(x)$y))]}

# Load data
Leb_PGG_3_Clean_FINAL <- read_dta('../data/Leb_PGG_3_Clean_FINAL.dta')

# Prepare data
df <- Leb_PGG_3_Clean_FINAL %>%
  
  # filter to only include Shia Female
  filter(sect == 'Sh', female == 1) %>%
  filter(final_assign == 1 | final_assign == 3) %>% 
  
  # Assign class_type (rich/poor)
  mutate(class_type = case_when(
    rich == 1 & poor == 0 ~ "rich",
    poor == 1 & rich == 0 ~ "poor",)) %>% 
  
  # Assign type (mix, same)
  mutate(type = case_when(
    T_mixed_class == 1 ~ "mix",
    T_mixed_class == 0 ~ "same",)) %>% 
  
  # Assign group_class (same_class_rich, same_class_poor, mixed_class)
  group_by(gid) %>%
  mutate(group_class = case_when(
    all(class_type == "rich") ~ "same_class_rich",
    all(class_type == "poor") ~ "same_class_poor",
    any(class_type == "rich") & any(class_type == "poor") ~ "mixed_class",)) %>% 
  
  # Scale contribution by 1000, so the "token range" is 0:10
  mutate(pgg_rd1 = pgg_rd1 / 1000) %>% 
  
  # Remove NAs
  filter(!is.na(pgg_rd1)) %>% 
  
  # Select columns of interest
  select(gid, pid, type, class_type, group_class, female, sect, pre_q2_age, pgg_rd1, pgg_rd1_totalpot)


# Split data into mix and same types
type_mix <- df %>% filter(type == 'mix')
type_same <- df %>% filter(type == 'same')

# Define nsub, ngroups, ntypes
subID_mix <- unique(type_mix$pid)
nsub_mix <- length(subID_mix) # 24
groupID_mix <- unique(type_mix$gid)
ngroups_mix <- length(groupID_mix) # 4 (with 6 subs in each)
ntypeID_mix <- unique(type_mix$type)
ntypes_mix <- length(ntypeID_mix) # 1

subID_same <- unique(type_same$pid)
nsub_same <- length(subID_same) # 24
groupID_same <- unique(type_same$gid)
ngroups_same <- length(groupID_same) # 4
ntypeID_same <- unique(type_same$type)
ntypes_same <- length(ntypeID_same) # 1

# Initialize empty arrays for c
c_mix <- array(NA, c(nsub_mix, ngroups_mix, 1))
c_same <- array(NA, c(nsub_same, ngroups_same, 1))

# Define function that loops through each group to assign subjects' pgg_rd1 (i.e. c) value
setup_arrays_c <- function(data, subID, groupID, c_array, nsub, ngroups) {
  for (g in 1:ngroups) {
    for (s in 1:nsub) {
      subject_data <- data %>%
        filter(gid == groupID[g] & pid == subID[s])
      if (nrow(subject_data) == 1) {
        c_array[s, g, 1] <- subject_data$pgg_rd1
      } else if (nrow(subject_data) > 1) {
        c_array[s, g, 1] <- subject_data$pgg_rd1[1] # Assign first value, caused error without 
      }
    }
  }
  
  return(c_array)
}

c_mix <- setup_arrays_c(type_mix, subID_mix, groupID_mix, c_mix, nsub_mix, ngroups_mix)
c_same <- setup_arrays_c(type_same, subID_same, groupID_same, c_same, nsub_same, ngroups_same)

# prepare for jags 
data <- list(c_mix = c_mix,
             c_same = c_same,
             nsub_mix = nsub_mix,
             nsub_same = nsub_same,
             ngroups_mix = ngroups_mix,
             ngroups_same = ngroups_same,
             ntypes_mix = ntypes_mix,
             ntypes_same = ntypes_same)

params <- c("diff_alpha", "diff_rho")

# Run jags
samples <- jags.parallel(data, inits = NULL, params,
                         model.file = "group_comparison.txt",
                         n.chains = 3, n.iter = 20000, n.burnin = 5000,
                         n.thin = 1, n.cluster = 4, jags.seed = 123)

save(samples, file = "../jags_output/group_diff_estimation.RData")


# Plotting!
source("plot_functions.R")

df <- data.frame(parameter = rep(c("alpha", "rho"),
                                 each = length(samples$BUGSoutput$sims.list$diff_alpha)),
                 samples = c(as.vector(samples$BUGSoutput$sims.list$diff_alpha), 
                             as.vector(samples$BUGSoutput$sims.list$diff_rho)))

pl1 <- diff_plot(df)
ggsave("../plots/post_dens_diff_means.png", plot = pl1, width = 6, height = 6, dpi = 300)


# diff_alpha, diff_rho
png("../plots/post_dens_diff_means2.png", width = 800, height = 600)
par(mfrow = c(1,2))
plot(density(rnorm(10000, 0, 1/sqrt(1))), ylim = c(0,.7), main = "Δα")
lines(density(samples$BUGSoutput$sims.list$diff_alpha), col = "cornflowerblue")
plot(density(rnorm(10000, 0, 1/sqrt(1))), ylim = c(0,.7), main = "Δρ")
lines(density(samples$BUGSoutput$sims.list$diff_rho), col = "cornflowerblue")
dev.off()


# trace plot, diff-alpha and diff-rho
png("../plots/traceplot_group_comparison.png", width = 800, height = 600)
traceplot(samples, mfrow = c(3, 1))
dev.off()

```

```{r}
samples
```


```{r}
# Save the sample table as .txt by captureing the printed output
output <- capture.output(print(samples))
writeLines(output, con = "../jags_output/comparison_summary.txt")
```


```{r}
traceplot(samples, mfrow = c(3, 1))
```

















